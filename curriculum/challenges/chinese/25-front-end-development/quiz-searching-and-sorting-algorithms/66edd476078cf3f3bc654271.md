---
id: 66edd476078cf3f3bc654271
title: 搜索与排序算法测验
challengeType: 8
dashedName: quiz-searching-and-sorting-algorithms
---

# --description--

要通过本测验，你必须正确回答以下 20 道题中的至少 17 道。

# --quizzes--

## --quiz--

### --question--

#### --text--

二分查找在最坏情况下的时间复杂度是多少？

#### --distractors--

O(n)

---

O(n^2)

---

O(1)

#### --answer--

O(log n)

### --question--

#### --text--

以下哪一个不是分治算法？

#### --distractors--

归并排序

---

快速排序

---

插入排序

#### --answer--

冒泡排序

### --question--

#### --text--

线性查找在最坏情况下的时间复杂度是多少？

#### --distractors--

O(log n)

---

O(1)

---

O(n log n)

#### --answer--

O(n)

### --question--

#### --text--

哪种排序算法将数组分成更小的子数组并按顺序合并？

#### --distractors--

快速排序

---

插入排序

---

冒泡排序

#### --answer--

归并排序

### --question--

#### --text--

冒泡排序的最佳时间复杂度是多少？

#### --distractors--

O(n^2)

---

O(log n)

---

O(n log n)

#### --answer--

O(n)

### --question--

#### --text--

快速排序在平均情况下的时间复杂度是多少？

#### --distractors--

O(n^2)

---

O(n)

---

O(log n)

#### --answer--

O(n log n)

### --question--

#### --text--

在算法设计中，分治法指的是什么？

#### --distractors--

逐个排序元素

---

线性遍历数组查找

---

交换相邻元素

#### --answer--

将问题分解为更小的子问题

### --question--

#### --text--

以下哪种算法在平均情况下对大型数据集最有效？

#### --distractors--

冒泡排序

---

归并排序

---

插入排序

#### --answer--

快速排序

### --question--

#### --text--

在二分查找中，数组需要满足什么条件？

#### --distractors--

数组必须包含唯一元素

---

数组必须是无序的

---

数组元素数量必须为偶数

#### --answer--

数组必须是有序的

### --question--

#### --text--

归并排序的空间复杂度是多少？

#### --distractors--

O(log n)

---

O(1)

---

O(n^2)

#### --answer--

O(n)

### --question--

#### --text--

冒泡排序在最坏情况下的时间复杂度是多少？

#### --distractors--

O(n)

---

O(n log n)

---

O(1)

#### --answer--

O(n^2)

### --question--

#### --text--

二分查找的最佳时间复杂度是多少？

#### --distractors--

O(n)

---

O(log n)

---

O(n^2)

#### --answer--

O(1)

### --question--

#### --text--

以下哪项是快速排序的关键特征？

#### --distractors--

它以线性时间排序元素

---

它不需要递归

---

它将数组分成两个等长部分

#### --answer--

它使用基准元素对数组进行分区

### --question--

#### --text--

线性查找的平均时间复杂度是多少？

#### --distractors--

O(n^2)

---

O(n log n)

---

O(log n)

#### --answer--

O(n)

### --question--

#### --text--

在快速排序中，当基准元素将数组完美地一分为二时会发生什么？

#### --distractors--

时间复杂度变为 O(n^2)

---

时间复杂度变为 O(n)

---

时间复杂度变为 O(log n)

#### --answer--

时间复杂度变为 O(n log n)

### --question--

#### --text--

归并排序相比快速排序的主要优势是什么？

#### --distractors--

归并排序时间复杂度更低

---

归并排序空间复杂度更优

---

归并排序避免递归

#### --answer--

归并排序在最坏情况下保证 O(n log n) 性能

### --question--

#### --text--

哪种排序算法通过比较和交换相邻元素进行排序？

#### --distractors--

快速排序

---

归并排序

---

选择排序

#### --answer--

冒泡排序

### --question--

#### --text--

当快速排序的基准元素总是最小或最大元素时，其时间复杂度是多少？

#### --distractors--

O(n)

---

O(log n)

---

O(n log n)

#### --answer--

O(n^2)

### --question--

#### --text--

分治法在排序算法中实现了什么？

#### --distractors--

提升空间复杂度

---

避免递归

---

仅适用于有序数组

#### --answer--

允许递归地解决子问题

### --question--

#### --text--

快速排序在最佳情况下的空间复杂度是多少？

#### --distractors--

O(n)

---

O(n log n)

---

O(n^2)

#### --answer--

O(log n)

