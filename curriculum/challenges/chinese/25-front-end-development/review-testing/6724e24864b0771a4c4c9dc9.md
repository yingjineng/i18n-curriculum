---
id: 6724e24864b0771a4c4c9dc9
title: 测试复习
challengeType: 24
dashedName: review-testing
---

# --description--

## 手动测试与自动化测试

- **手动测试**：在手动测试中，测试人员会手动检查应用程序的每个部分，测试不同的功能以确保其正常工作。如果在测试过程中发现任何 bug，测试人员会将这些 bug 报告给软件团队，以便修复。
- **自动化测试**：在自动化测试中，你可以通过编写单独的程序来自动检查应用程序是否按预期运行。

## 单元测试

- **单元测试**：单元测试是对每个函数进行测试，以确保一切按预期工作。单元测试还可以作为应用程序的文档，因为它们代表了代码的预期行为。
- **单一职责原则**：单一职责原则建议每个函数应保持简洁，只负责一件事。
- **常见的 JavaScript 测试框架**：常见的测试框架包括 Jest、Mocha 和 Vitest。Jest 是一个流行的单元测试框架。

以下是使用 Jest 进行单元测试的示例。

首先，你可以创建一个用于返回格式化字符串的函数：

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

在单独的 `getFormattedWord.test.js` 文件中，你可以编写一些测试来验证该函数是否按预期工作。`getFormattedWord.test.js` 文件如下：

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **`expect` 函数**：`expect` 函数用于测试一个值。
- **匹配器**：匹配器是用于检查值是否符合预期的函数。在上面的例子中，匹配器是 `toBe()`。Jest 提供了多种匹配器。

要使用 Jest，首先需要通过 `npm i jest` 安装 `jest` 包。你还需要在 `package.json` 文件中添加如下脚本：

```js
"scripts": {
  "test": "jest"
},
```

然后，你可以运行 `npm run test` 命令来执行测试。

## 软件开发生命周期

- **软件开发生命周期的不同阶段**：
  - **规划阶段**：开发团队从利益相关者那里收集所需的需求。
  - **设计阶段**：软件团队分解需求，并决定最佳的解决方案。
  - **实现阶段**：软件团队将需求分解为可管理的任务并实现它们。
  - **测试阶段**：包括对新功能进行手动和自动化测试。有时，团队会在整个开发阶段持续测试应用程序，以便及时发现和修复问题。
  - **部署阶段**：团队将新更改部署到构建或测试环境中。
  - **维护阶段**：修复生产环境中客户反馈的问题。

- **软件开发生命周期的不同模型**：
  - **瀑布模型**：瀑布模型要求每个阶段完成后才能进入下一个阶段。
  - **敏捷模型**：敏捷模型注重迭代开发，将工作分解为短周期的冲刺（sprint）。

## BDD 与 TDD

- **TDD**：测试驱动开发是一种强调先编写测试的开发方法。在开发功能前先写测试，可以为开发者提供实时反馈。
- **BDD**：行为驱动开发是一种将测试场景与业务目标对齐的方法。BDD 的测试场景应以技术和非技术人员都能理解的语言编写，如 Gherkin 语法。
- **BDD 测试框架**：常见的 BDD 测试框架有 Cucumber、JBehave 和 SpecFlow。

## 单元测试中的断言

- **断言**：断言用于测试代码是否按预期运行。
- **断言库**：Chai 是常用的断言库。其他常见的 JavaScript 断言库有 `should.js` 和 `expect.js`。

以下是使用 Chai 断言的示例，检查 `addThreeAndFour` 函数的返回值是否等于 7：

```js
assert.equal(addThreeAndFour(), 7);
```

- **最佳实践**：无论使用哪种断言库，都应编写清晰的断言和失败信息，以便理解哪些测试失败以及原因。

## Mock、Fake 和 Stub

- **Mock（模拟）**：Mock 是用虚假数据替换真实数据，模拟真实组件的行为。例如，在测试中可以模拟 API 响应，而不是频繁调用真实 API。
- **Stub（桩）**：Stub 是返回预定义响应或虚拟数据的对象，用于模拟应用程序中的特定行为。例如，可以在测试中为数据库连接设置桩，而无需依赖真实数据库。
- **Fake（伪对象）**：Fake 是真实组件的简化版本，没有复杂性或副作用。例如，可以通过内存存储数据来伪造数据库操作，这比操作真实数据库更快。

## 功能测试

- **功能测试**：功能测试检查应用程序的功能和特性是否按预期工作。其目标是针对多种场景测试整个系统。
- **非功能测试**：非功能测试关注性能和可靠性等方面。
- **冒烟测试**：冒烟测试是在进行更全面测试前，对系统进行初步检查，发现基本或关键问题。

## 端到端测试

- **端到端测试**：端到端测试（E2E）从用户角度测试真实场景，确保应用程序行为正确且可预测。但设置、设计和维护端到端测试较为耗时。
- **端到端测试框架**：Playwright 是微软开发的流行端到端测试框架。其他工具包括 Cypress、Selenium 和 Puppeteer。

以下是 freeCodeCamp 代码库中使用 Playwright 进行 E2E 测试的示例。`beforeEach` 钩子会在每个测试前运行。测试检查捐赠者在菜单栏中有支持者链接，以及头像有特殊边框：

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## 可用性测试

- **可用性测试**：可用性测试是让真实用户与应用程序交互，发现设计、用户体验或功能上的问题。可用性测试关注应用程序对用户的直观性。
- **四种常见的可用性测试类型**：
  - **探索性**：用户与应用的不同功能交互，以更好地理解其工作方式。
  - **对比性**：将你的应用与市场上类似应用的用户体验进行对比。
  - **评估性**：研究应用的易用性。
  - **验证性**：识别阻碍用户有效使用应用的主要问题。
- **可用性测试工具**：常见工具有 Loop11、Maze、Userbrain、UserTesting 和 UXTweak。

## 兼容性测试

- **兼容性测试**：兼容性测试的目标是确保应用程序能在不同的计算环境下正常运行。
- **兼容性测试的不同类型**：
  - **向后兼容**：软件能兼容早期版本。
  - **向前兼容**：软件和系统能兼容未来版本。
  - **硬件兼容**：软件能在不同硬件配置下正常运行。
  - **操作系统兼容**：软件能在不同操作系统（如 macOS、Windows、Ubuntu、Fedora 等 Linux 发行版）上运行。
  - **网络兼容**：软件能适应不同的网络条件，如不同的网速、协议、安全设置等。
  - **浏览器兼容**：Web 应用能在不同浏览器（如 Chrome、Safari、Firefox 等）下表现一致。
  - **移动端兼容**：确保应用能在各种 Android 和 iOS 设备（包括手机和平板）上正常运行。

## 性能测试

- **性能测试**：性能测试用于测试应用在不同负载下的速度、响应性、可扩展性和稳定性，目标是解决性能瓶颈。
- **性能测试的不同类型**：
  - **负载测试**：测试系统在正常和高峰负载下的表现。
  - **压力测试**：在极端负载下测试应用，观察系统的响应能力。
  - **耐久测试（浸泡测试）**：在长时间高负载下测试系统的稳定性。
  - **突发测试**：突然大幅增加或减少负载，分析系统的反应。
  - **容量测试**：逐步增加负载，直到系统开始失效或性能下降。

## 安全测试

- **安全测试**：安全测试用于识别系统中的漏洞和弱点。
- **安全原则**：
  - **机密性**：防止敏感信息泄露给非授权用户。
  - **完整性**：防止恶意用户篡改用户信息。
  - **认证**：验证用户身份，确保其有权使用系统。
  - **授权**：决定已认证用户可以执行哪些操作或访问系统的哪些部分。
  - **可用性**：确保信息和服务在需要时对授权用户可用。
  - **不可否认性**：确保发送方和接收方都有交付和身份验证的证据，防止发送方否认发送信息。
- **常见安全威胁**：
  - **跨站脚本攻击（XSS）**：攻击者向网页注入恶意脚本，并在受害者浏览器中执行。
  - **SQL 注入**：恶意用户向数据库注入恶意代码。
  - **拒绝服务攻击（DoS）**：恶意用户向网站发送大量请求，导致服务器变慢甚至崩溃，使网站无法访问。
- **安全测试工具类别**：
  - **静态应用安全测试**：这些工具分析应用源代码，查找安全漏洞。
  - **动态应用安全测试**：这些工具与应用前端交互，发现潜在的安全弱点。DAST 工具无法访问源代码。
- **渗透测试（pentest）**：渗透测试是通过模拟网络攻击，发现系统中的安全漏洞。

## A/B 测试

- **A/B 测试**：A/B 测试是对比两个页面或应用版本，研究哪个版本表现更好，也称为分桶测试或分流测试。A/B 测试有助于做出数据驱动的决策，不断提升用户体验。
- **A/B 测试工具**：常见工具有 GrowthBook 和 LaunchDarkly。

## Alpha 与 Beta 测试

在初步开发和软件测试完成后，让测试人员和真实用户参与测试非常重要，这就是 Alpha 和 Beta 测试的作用。

- **Alpha 测试**：由一组特定测试人员进行，确保应用在发布前没有 bug。Alpha 测试属于验收测试，采用白盒和黑盒测试技术。
- **Beta 测试**：应用对真实用户开放，用户可以交互并反馈。Beta 测试也是用户验收测试的一种。
- **验收测试**：确保软件应用满足业务需求和用户需求，才能发布。
- **黑盒测试**：只关注应用的预期行为。
- **白盒测试**：测试人员了解内部组件并对其进行测试。

## 回归测试

- **回归**：指新更改无意中破坏了现有功能的情况。
- **回归测试**：回归测试有助于发现回归问题。通过重新运行功能测试，确保应用的各部分仍然正常。
- **回归测试工具**：可用于回归测试的工具有 Puppeteer、Playwright、Selenium 和 Cypress。
- **回归测试技术**：
  - **单元回归测试**：每次重大更改或修复后，测试一组需要验证的项目。
  - **部分回归测试**：有针对性地确保新更改未破坏应用的特定部分。
  - **完全回归测试**：对代码库的所有功能进行测试，最为耗时和详细。
- **复测**：用于检查已知问题是否已解决。相比之下，回归测试用于查找最近更改可能引入的未知问题。

# --assignment--

复习测试相关主题和概念。

